#+Title: C, Crypto & Clojure
#+Author: @lvh
#+Email: _@lvh.io

#+OPTIONS: toc:nil reveal_rolling_links:nil num:nil reveal_history:true
#+OPTIONS: timestamp:nil
#+REVEAL_TRANS: linear
#+REVEAL_THEME: lvh

* Slides

  https://lvh.io/CCryptoClojure

* Introduction

** ã€€

   #+REVEAL_HTML: <img style="width:70%" src="./media/lvh.svg">

** ã€€
   :PROPERTIES:
   :reveal_background: #DFEFDE
   :END:

   #+REVEAL_HTML: <img style="width:70%" src="./media/Latacora.svg">

** C, Crypto & Clojure

   (with âœ¨)

** Why Clojure?

   * We ðŸ’– Clojure
   * Easier R&D

** Why crypto?

   * That's what I do
   * Don't implement your own crypto
   * ~PCLMULQDQ~, ~AES-NI~, &c

** Why C?

   * More about OS ABI ("native code") than C
   * Converse: "why only use the JVM?"
   * Crypto, OS features, native GUI, GPU...

* Let's call native code!

  (on the JVM, for now)

** How do you call native code?

   #+ATTR_REVEAL: :frag (roll-in)
   * JNI
   * JNA
   * JNR

** JNI

   Code â†’ JNI call

   #+ATTR_HTML: :style font-size:50px;transform:rotate(135deg)
   âŸ¿

   ~JNI impl -> lib~

** JNI

 #+BEGIN_SRC java
   private native void doSomething();
 #+END_SRC

** JNI

   ~javah~ + toolchain


** JNI

 #+BEGIN_SRC java
   public class NativeStuff {
       public static native long getpid();
       public static void main(String[] args) {
           getpid();
       }
       static {
           System.load("/some/dir/nativestuff.dylib");
       }
   }
 #+END_SRC

** ~javah~ output

#+BEGIN_SRC c
  /* DO NOT EDIT THIS FILE - it is machine generated */
  #include <jni.h>
  /* Header for class io_lvh_cljn_NativeStuff */
  #ifndef _Included_io_lvh_cljn_NativeStuff
  #define _Included_io_lvh_cljn_NativeStuff
  #ifdef __cplusplus
  extern "C" {
  #endif
    /*
     ,* Class:     io_lvh_cljn_NativeStuff
     ,* Method:    getpid
     ,* Signature: ()J
     ,*/
    JNIEXPORT jlong JNICALL Java_io_lvh_cljn_NativeStuff_getpid (JNIEnv *, jclass);
  #ifdef __cplusplus
  }
  #endif
  #endif
#+END_SRC

** JNI implementation

   #+BEGIN_SRC c
     #include "lvh_io_cljn_NativeStuff.h"
     jlong JNICALL Java_lvh_io_cljn_NativeStuff_getpid
     (JNIEnv *env, jclass c) {
       return getpid();
     }
#+END_SRC

** JNI

   neanderthal â†’ opencl â†’ jocl

   #+BEGIN_SRC java
     static native boolean initNativeLibrary(String fullName);
   #+END_SRC

** JNI

   Great, if someone else does the compily bit

** JNA

#+BEGIN_SRC java
  import com.sun.jna.Library;
  import com.sun.jna.Native;
  public class NativeStuff {
      public interface GetPid extends Library {
          long getpid();
      }
      public static void main(String[] args) {
          GetPid getpid = (GetPid)Native.loadLibrary(GetPid.class);
          getpid.getpid();
      }
  }
#+END_SRC

** JNA

   Perf matters

** JNR

   Code â†’ JNR stub â†’ JNI call

   #+ATTR_HTML: :style font-size:50px;transform:rotate(150deg)
   âŸ¿

   ~JNI impl -> libffi -> lib~

** Worst of both worlds?!

   * JNI part is shared

** ~jnr-ffi~

   #+BEGIN_src java
     public interface LibC  {
         public int gettimeofday(
             @Out @Transient Timeval tv,
             Pointer unused
         );
     }
   #+END_src

** struct

   #+BEGIN_src java
     public static final class Timeval extends Struct {
         public final time_t tv_sec = new time_t();
         public final SignedLong tv_usec = new SignedLong();
     }
   #+END_src

** Thanks JRuby!

   fs, subprocesses, stat, tty/pty/fcntl, fast IO

** Off-the-shelf

   ~jnr-posix~, ~jnr-enxio~, ~jnr-unixsocket~, ...

* Let's go write some Java!

** ~libsodium~

   * Cryptographic library
   * nacl but buildable and with cheese

** How much Java?

   #+BEGIN_src shell
   $ wc -l **h
   ...
   9166 total
   #+END_src

   ðŸ˜°

** Well, OK, but it's easy Java, right?

   Mostly ~char *~

** So many JVM types

   Pointer, Buffer, String, [B, ByteBuffer...

** Return type?

   One per fn, or by input type?

** Functional vs mutate in place

   * ~void f(*int out, int x)~
   * ~int f(int x)~

** Getting to the right type

   * Conversions? (Copying!)
   * Reflection? (Slow!)
   * Explicit dispatch? (Large methods!)
   * Give specific type? (Hard to use!)

** Combinatorial explosion

   ~thousands exposed syms

** Pick a type

   * Pointer, Buffer: ðŸš«
   * String: ðŸš« (except constants)
   * [B, ByteBuffer: ?

** [B advantages

   * By far most common type
   * Easy to use, e.g. serializers

** ByteBuffer advantages

   * Supported API for "direct" allocation
   * Cheap slicing, "views" over memory

** Asymmetry

   ByteBuffer â†’ byte array: fast!

   byte array â† ByteBuffer: slow!

** Conclusion

   * Expose everything
   * In-place API:
     * Takes buffers only
   * Functional:
     * Takes anything, wraps to buf
     * Returns a byte array

* How Clojure helped

** Host interop

   Doesn't hide Java/JVM

** definterface

   #+BEGIN_src clojure
     (definterface LibC
       (^int gettimeofday
        [^Timeval ^{Out {} Transient {}} tv
         ^Pointer unused]))
   #+END_src

** The Clojure way

   * Have data
   * Don't mess it up

** Expose every byte type

   ~(mapcat permuted-byte-types raw-bound-fns)~

   * Specify once with bytes
   * Get ByteBuffer permutations for free

** ~@IgnoreError~

   * JVM (OpenJDK) uses ~errno~
   * So does some C code
   * Gotta save and restore

** ~@IgnoreError~

   Just map a function over some values

** ~defconsts~

   #+BEGIN_SRC clojure
     ;; in caesium.crypto.secretbox
     (defconsts [keybytes noncebytes macbytes primitive])
   #+END_SRC

** âœ¨

   #+BEGIN_SRC clojure
     ;; in caesium.crypto.box
     (âœ¨ open-easy m c n pk sk)
     ;; =>
     (.crypto_box_open_easy
      m c (long (buflen c))
      n pk sk)
    #+END_SRC


* Performance

** Performance

   * Penalty is tiny
   * JVM tooling is cool

** jitwatch

   [[./media/jitwatch.png]]

** Getting ASM dumps

   ~-XX:+UnlockDiagnosticVMOptions~

   ~-XX:+PrintAssembly~

** Getting ASM dumps

   #+BEGIN_SRC text
     Java HotSpot(TM) 64-Bit Server VM
     warning: PrintAssembly is enabled;
       turning on DebugNonSafepoints to gain additional output
     ... yada yada yada ...
   #+END_SRC

** Getting ASM dumps

   #+BEGIN_SRC text
     Java HotSpot(TM) 64-Bit Server VM
     warning: PrintAssembly is enabled;
       turning on DebugNonSafepoints to gain additional output
     Could not load hsdis-amd64.dylib;
       library not loadable; PrintAssembly is disabled
   #+END_SRC

** acquire hsdis

   * check out OpenJDK
   * build a binutils
   * extensive cursing

** hsdis

   #+ATTR_HTML: :style font-size:60%
   #+BEGIN_SRC asm
     0x00007fb8a181a2e0: mov    DWORD PTR [rsp-0x14000],eax
     0x00007fb8a181a2e7: push   rbp
     0x00007fb8a181a2e8: sub    rsp,0x30
     ;*aload_0
     ; - clojure.lang.ASeq::size@0 (line 188)
     0x00007fb8a181a2ec: nop
     0x00007fb8a181a2ed: movabs rax,0xffffffffffffffff
     0x00007fb8a181a2f7: call   0x00007fb8a1045f60
     ; OopMap{off=60}
     ;*invokevirtual count
     ; - clojure.lang.ASeq::size@1 (line 188)
     ;   {virtual_call}
     0x00007fb8a181a2fc: add    rsp,0x30
     0x00007fb8a181a300: pop    rbp
     0x00007fb8a181a301: test   DWORD PTR [rip+0x18527df9],eax
   #+END_SRC

* Conclusion

** Yay open sores

   * At least one bug in jnr
   * At least one bug in Clojure
   * Zero-copy for cffi (Python)

* Nonce-misuse resistant cryptography

** Encrypting with nonces

   Number used once

** What if I don't?

   * Probably decrypt those ctexts
   * Arbitrary forgeries afterwards

** API

   ~E(k, n, p) -> c~

** Is this the default API we want?

** GCM has other problems

   (not gonna talk about them now)

** Confusing!

   GCM was the good ciphersuite, right?!

** TLS alternatives are worse

** GCM is fine /in 1 specific case/

   * Short-lived keys
   * Coordination about nonces

   ... so just use TLS!

** Distributed systems

   Encrypting a cookie or DB entry

** Programmers don't grok IVs/nonces

   Evidence in how often they...

   * mess them up
   * end up with ECB

** OK, so randomize the nonce!

   Nope!

   * GCM: 96 bits
   * Salsa20: 64 bits

** People still mess it up

   * Nonce reuse in TLS
   * Bad random during encryption

** Fernet

   * Right API! ~E(k, p) -> c~
   * Safe! (IND-CCA2, EtM)
   * Weird choices
   * Encryption-time random

** Goals

   Fernet, modern crypto done right

** Goals

   * Easy API
   * Only safe choices
   * Easy to implement
   * Easy security proof
   * Wide security margin
   * Fast enough (~10% penalty)

** Busted RNG & reused nonce

   total catastrophe

   (decrypt, forge)

   â¬‡

   attacker can detect duplicates

   (not decrypt, not forge)

** Idea: synthesize nonce from plaintext

   (maybe mix with randomness)

** Started as research about "keywrap"

   Deterministic encryption

** ~magicnonce~

   * ~secretbox-rnd~
   * ~secretbox-det~
   * ~secretbox-nmr~

** Rough idea

   BLAKE2b as a PRF â†’  nonce
   XSalsa20 + Poly1305 (big nonce space)

** Perf!

   Pretty good (but wait for the paper)

** What about CAESAR?

   * Serves any masters!
   * Only 1 NMR suite in round 3: AEZ
   * Perf always worse, but how much?
   * Not worth it for TLS-like protocols

** What about GCM-SIV?

* Q&A

  ~@lvh~

  ~_@lvh.io~

  ~lvh@latacora.com~, ~https://latacora.com~

* Slides

  https://lvh.io/CCryptoClojure
