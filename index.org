#+Title: C, Crypto & Clojure
#+Author: @lvh
#+Email: _@lvh.io

#+OPTIONS: toc:nil reveal_rolling_links:nil num:nil reveal_history:true
#+OPTIONS: timestamp:nil
#+REVEAL_TRANS: linear
#+REVEAL_THEME: lvh

* Introduction

** Who am I?

   #+BEGIN_HTML
   <img style="width:70%" src="./media/lvh.svg">
   #+END_HTML

** ‌Latacora

** C, Crypto & Clojure

   (with ✨)

** ~(apply clojure @life)~

   * Modern lisp
   * Targets /JVM/, JS, CLR

** Why Clojure?

   * I love Clojure
   * Easier R&D

** Why crypto?

   * That's what I do
   * Don't implement your own crypto
   * ~PCLMULQDQ~, ~AES-NI~, &c

** Why C?

   * More about OS ABI ("native code") than C
   * Converse: "why only use the JVM?"
   * Crypto, OS features, native GUI, GPU...

* Let's call some native code!

** How do you call native code?

   #+ATTR_REVEAL: :frag (roll-in)
   * JNI 😭
   * JNA 😢
   * JNR 😒

** JNI

   Code → JNI call

   #+ATTR_HTML: :style font-size:50px;transform:rotate(135deg)
   ⟿

   ~JNI impl -> lib~

** JNA

   Perf matters

** JNR

   Code → JNR stub → JNI call

   #+ATTR_HTML: :style font-size:50px;transform:rotate(150deg)
   ⟿

   ~JNI impl -> libffi -> lib~

** ~jnr-ffi~

   #+BEGIN_src java
     public interface LibC  {
         public int gettimeofday(
             @Out @Transient Timeval tv,
             Pointer unused
         );
     }
   #+END_src

** struct

   #+BEGIN_src java
     public static final class Timeval extends Struct {
         public final time_t tv_sec = new time_t();
         public final SignedLong tv_usec = new SignedLong();
     }
   #+END_src

** Thanks JRuby!

   fs, subprocesses, stat, tty/pty/fcntl, fast IO

** Off-the-shelf

   ~jnr-posix~, ~jnr-enxio~, ~jnr-unixsocket~, ...

* Let's go write some Java!

** How much Java?

   #+BEGIN_src shell
   $ wc -l **h
   ...
   9166 total
   #+END_src

   😰

** Well, OK, but it's easy Java, right?

   * libsodium is mostly ~char *~
   * That should be easy to bind

** So many types

   Pointer, Buffer, String, [B, ByteBuffer...

** Return type?

   One per fn, or by input type?

** Functional vs mutate in place

   * ~void f(*int out, int x)~
   * ~int f(int x)~

** Getting to the right type

   * Conversions? (Copying!)
   * Reflection? (Slow!)
   * Explicit dispatch? (Large methods!)
   * Give specific type? (Hard to use!)

** Combinatorial explosion

   ~thousands exposed syms

** Pick a type

   * Pointer, Buffer: 🚫
   * String: 🚫 (except constants)
   * [B, ByteBuffer: ?

** [B advantages

   * By far most common type
   * Easy to use, e.g. serializers

** ByteBuffer advantages

   * Supported API for "direct" allocation
   * Cheap slicing, "views" over memory

** Asymmetry

   ByteBuffer → byte array: fast!

   byte array ← ByteBuffer: slow!

** Conclusion

   * Expose everything
   * In-place API:
     * Takes buffers only
   * Functional:
     * Takes anything, wraps to buf
     * Returns a byte array

* How Clojure helped

** Host interop

   Doesn't hide Java/JVM

** definterface

   #+BEGIN_src clojure
     (definterface LibC
       (^int gettimeofday
        [^Timeval ^{Out {} Transient {}} tv
         ^Pointer unused]))
   #+END_src

** The Clojure way

   * Have data
   * Don't mess it up

** Expose every byte type

   ~(mapcat permuted-byte-types raw-bound-fns)~

   * Specify once with bytes
   * Get ByteBuffer permutations for free

** ~@IgnoreError~

   * JVM (OpenJDK) uses ~errno~
   * So does some C code
   * Gotta save and restore

** ~@IgnoreError~

   Just map a function over some values

** ~defconsts~

   #+BEGIN_SRC clojure
     ;; in caesium.crypto.secretbox
     (defconsts [keybytes noncebytes macbytes primitive])
   #+END_SRC

** ✨

   #+BEGIN_SRC clojure
     ;; in caesium.crypto.box
     (✨ open-easy m c n pk sk)
     ;; =>
     (.crypto_box_open_easy
      m c (long (buflen c))
      n pk sk)
    #+END_SRC

** Performance

   * Penalty measured in ~2 x86_64 instrs
   * Branch-prediction-friendly

** JVM tooling is awesome

   #+BEGIN_SRC text

       0x00007fb8a181a2d6: cmp    rax,QWORD PTR [rsi+0x8]
       0x00007fb8a181a2da: jne    0x00007fb8a1045b60  ;   {runtime_call}
     [Verified Entry Point]
       0x00007fb8a181a2e0: mov    DWORD PTR [rsp-0x14000],eax
       0x00007fb8a181a2e7: push   rbp
       0x00007fb8a181a2e8: sub    rsp,0x30           ;*aload_0
                                                     ; - clojure.lang.ASeq::size@0 (line 188)

       0x00007fb8a181a2ec: nop
       0x00007fb8a181a2ed: movabs rax,0xffffffffffffffff
       0x00007fb8a181a2f7: call   0x00007fb8a1045f60  ; OopMap{off=60}
                                                     ;*invokevirtual count
                                                     ; - clojure.lang.ASeq::size@1 (line 188)
                                                     ;   {virtual_call}
       0x00007fb8a181a2fc: add    rsp,0x30
       0x00007fb8a181a300: pop    rbp
       0x00007fb8a181a301: test   DWORD PTR [rip+0x18527df9],eax        # 0x00007fb8b9d42100
   #+END_SRC

** Yay open sores

   * At least one bug in jnr
   * At least one bug in Clojure
   * Zero-copy for cffi (Python)

* Nonce-misuse resistant cryptography

** Encrypting with nonces

   Number used once

** What if I don't?

   * Probably decrypt those ctexts
   * Arbitrary forgeries afterwards

** API

   ~E(k, n, p) -> c~

** Is this the default API we want?

** GCM has other problems

   (not gonna talk about them now)

** Confusing!

   GCM was the good ciphersuite, right?!

** TLS alternatives are worse

** GCM is fine /in 1 specific case/

   * Short-lived keys
   * Coordination about nonces

   ... so just use TLS!

** Distributed systems

   Encrypting a cookie or DB entry

** Programmers don't grok IVs/nonces

   Evidence in how often they...

   * mess them up
   * end up with ECB

** OK, so randomize the nonce!

   Nope!

   * GCM: 96 bits
   * Salsa20: 64 bits

** People still mess it up

   * Nonce reuse in TLS
   * Bad random during encryption

** Fernet

   * Right API! ~E(k, p) -> c~
   * Safe! (IND-CCA2, EtM)
   * Weird choices
   * Encryption-time random

** Goals

   Fernet, modern crypto done right

** Goals

   * Easy API
   * Only safe choices
   * Easy to implement
   * Easy security proof
   * Wide security margin
   * Fast enough (~10% penalty)

** Busted RNG & reused nonce

   total catastrophe

   (decrypt, forge)

   ⬇

   attacker can detect duplicates

   (not decrypt, not forge)

** Idea: synthesize nonce from plaintext

   (maybe mix with randomness)

** Started as research about "keywrap"

   Deterministic encryption

** ~magicnonce~

   * ~secretbox-rnd~
   * ~secretbox-det~
   * ~secretbox-nmr~

** Rough idea

   BLAKE2b as a PRF →  nonce
   XSalsa20 + Poly1305 (big nonce space)

** Perf!

   Pretty good (but wait for the paper)

** What about CAESAR?

   * Serves any masters!
   * Only 1 NMR suite in round 3: AEZ
   * Perf always worse, but how much?
   * Not worth it for TLS-like protocols

** What about GCM-SIV?

* Q&A

  ~@lvh~

  ~_@lvh.io~
